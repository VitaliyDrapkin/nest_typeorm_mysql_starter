---
description: Guidelines for implementing pagination in NestJS controllers and services
alwaysApply: false
---

# NestJS Pagination Implementation Guidelines

## Core Principle

Use shared pagination infrastructure: `PaginationQueryDto`, `PaginationResponseDto`, and `PaginationTransformer`. Never implement custom pagination logic.

## Required Components

### 1. Query DTO - Extend PaginationQueryDto

```typescript
import { PaginationQueryDto } from '@src/shared/dtos/pagination.query.dto';

export class GetUsersQueryDto extends PaginationQueryDto {
  @IsString()
  @IsOptional()
  email?: string;
}
```

Provides: `skip` (default: 0), `take` (default: 100), validation, Swagger docs.

### 2. Response DTO - Extend PaginationResponseDto

```typescript
import { PaginationResponseDto } from '@src/shared/dtos/pagination.response.dto';

export class GetUsersResponseDto extends PaginationResponseDto<UserResponseDto> {
  data: UserResponseDto[];
}
```

Provides: `totalItems`, `totalPages`, `currentPage`, `itemsPerPage`, `hasNextPage`, `hasPreviousPage`, `data`.

### 3. Service - Use PaginationTransformer

```typescript
async getMany(query: GetExampleQueryDto): Promise<PaginationResponseDto<ExampleResponseDto>> {
  const [items, total] = await this.repository.getManyByQuery(filters, {
    skip: query.skip,
    take: query.take,
  });

  return PaginationTransformer.toPaginationResponseDto(
    items,
    total,
    query.take,
    query.skip,
  );
}
```

**With custom transformation:**

```typescript
return PaginationTransformer.toPaginationResponseDto(
  items,
  total,
  query.take,
  query.skip,
  (item) => ({
    id: item.id,
    // custom transformation logic
  }),
);
```

## Repository Usage

Always use `getManyByQuery` with pagination options:

```typescript
const [items, total] = await this.repository.getManyByQuery(filters, {
  skip: query.skip,
  take: query.take,
});
```

## Best Practices

- Extend `PaginationQueryDto` for query DTOs
- Extend `PaginationResponseDto<T>` for response DTOs
- Add filter properties as optional fields with validation
- Use descriptive method names: `getMany`, `getUsers` (not `getAll` or `list`)
- Keep filter logic in services, not repositories
- Set reasonable limits (max 1000 items)
- Use database indexes for filtered fields

## Anti-Patterns (Don't Do)

❌ Custom pagination logic
❌ Not extending `PaginationQueryDto`
❌ Returning raw entities without transformation
❌ Custom repository wrappers for simple pagination

## Summary

1. Query DTOs → extend `PaginationQueryDto`
2. Response DTOs → extend `PaginationResponseDto<T>`
3. Services → use `PaginationTransformer.toPaginationResponseDto()`
4. Repositories → use `getManyByQuery(filters, { skip, take })`
