---
globs: src/modules/**/dto/**/*.ts
---

# DTO Guidelines

## Directory Structure

### Simple module (single communication type):

```
module/
└── dto/
    ├── queries/   # GET request parameters and filters
    ├── requests/  # POST/PUT/PATCH request bodies
    └── responses/ # Response DTOs
```

### Module with multiple communication types (HTTP, WebSocket, GraphQL):

If a module uses multiple communication types, create separate folders for each type:

```
module/
└── dto/
    ├── http/
    │   ├── queries/
    │   ├── requests/
    │   └── responses/
    ├── ws/
    │   ├── requests/
    │   └── responses/
    └── graphql/
        ├── inputs/
        └── objects/
```

## Naming Conventions

- **Query DTOs**: `[Entity]QueryDto` (e.g., `UserQueryDto`)
- **Request DTOs**: `[Action][Entity]RequestDto` (e.g., `CreateUserRequestDto`)
- **Response DTOs**: `[Entity]ResponseDto` (e.g., `UserResponseDto`)
- **Broadcast DTOs** (WebSocket): `[Action][Entity]BroadcastDto` (e.g., `UserJoinedBroadcastDto`)

## Core Principles

### Validation

Always use `class-validator` decorators for validation:

```typescript
import { IsString, IsEmail, MinLength, IsOptional } from 'class-validator';

export class CreateUserRequestDto {
  @IsString()
  @MinLength(2)
  name: string;

  @IsEmail()
  email: string;

  @IsOptional()
  @IsString()
  bio?: string;
}
```

### Transform for Query DTOs

Use `@Transform` in query DTOs for correct data transformation (all query parameters come as strings):

```typescript
import { Transform } from 'class-transformer';
import { IsOptional, IsNumber } from 'class-validator';

export class UserQueryDto {
  @IsOptional()
  @Transform(({ value }) => value?.trim())
  name?: string;

  @IsOptional()
  @IsNumber()
  @Transform(({ value }) => parseInt(value))
  age?: number;
}
```

### Expose for Response DTOs

Use `@Expose()` to control serialization in response DTOs:

```typescript
import { Exclude, Expose } from 'class-transformer';

@Exclude()
export class UserResponseDto {
  @Expose()
  id: string;

  @Expose()
  name: string;

  @Expose()
  email: string;

  // password will not be included in response
}
```

### Reusability through extend

Use `PartialType` and `OmitType` for DTO reusability:

```typescript
import { PartialType, OmitType } from '@nestjs/swagger';

// All fields are optional
export class UpdateUserDto extends PartialType(CreateUserDto) {}

// Exclude specific fields
export class UpdateUserDto extends PartialType(
  OmitType(CreateUserDto, ['password']),
) {}
```

## Important Notes

1. Use `plainToInstance()` to transform entity to response DTO
2. Response DTOs must use `@Exclude()` + `@Expose()` for security
3. Query DTOs must use `@Transform()` for correct type conversion
4. Use inheritance (`extends`) to avoid code duplication
5. For pagination, use `PaginationQueryDto` and `PaginationResponseDto` (see [@pagination.mdc](pagination.mdc))

## Pagination Integration

**MANDATORY:** For paginated requests:

- Query DTOs must extend `PaginationQueryDto`
- Response DTOs must extend `PaginationResponseDto<T>`

For details, see [@pagination.mdc](pagination.mdc)
