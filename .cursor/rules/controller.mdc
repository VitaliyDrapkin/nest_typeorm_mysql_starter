---
globs: src/modules/**/controllers/*.ts
---

# NestJS Controller and DTO Structure Guidelines

This document outlines the best practices for structuring NestJS controllers in our project.

## Controller Structure

### File Location

- Place controllers in `src/modules/{module-name}/controllers/`
- Name files as `{feature}.controller.ts`

### Controller Decorators

- Always use `@Controller()` with a meaningful route prefix
- Use `@ApiTags()` for Swagger documentation
- Group related endpoints logically

### Method Organization

- Group CRUD operations together
- Use appropriate HTTP method decorators (`@Get`, `@Post`, `@Put`,`@Patch`, `@Delete`)
- Include proper parameter decorators (`@Body`, `@Param`, `@Query`)

### Data Transfer Objects (DTOs)

Data for request bodies, query parameters, and responses should be obtained using DTOs. DTOs provide type safety, validation, and clear contract definitions between client and server.

- **Request Body**: Use `@Body()` with request DTOs for POST/PUT/PATCH operations
- **Query Parameters**: Use `@Query()` with query DTOs for GET operations with filters
- **Response Data**: Use response DTOs to define the structure of returned data

For detailed DTO guidelines and examples, see [@dto-rule.mdc](./dto-rule.mdc).

## Decorators

- **@CurrentUser()** - extracts user information from JWT token automatically
- **@Public()** - marks route as publicly accessible, bypassing JWT authentication
- **@CustomTimeout()** - sets custom timeout for long-running operations
- **@Roles()** - restricts access based on user roles

For comprehensive decorator usage guidelines and examples, see [@decorators.mdc](./decorators.mdc).

## Business Logic Prohibition

**CRITICAL**: Controllers should NEVER contain business logic. Controllers only delegate to services.

### ❌ Bad - Business Logic in Controller

```typescript
@Controller('users')
export class UsersController {
  @Post()
  async create(@Body() dto: CreateUserRequestDto) {
    // ❌ NO! Business logic in controller
    const existingUser = await this.userRepository.findByEmail(dto.email);
    if (existingUser) {
      throw new ConflictException('User already exists');
    }
    const hashedPassword = await bcrypt.hash(dto.password, 10);
    return this.userRepository.save({ ...dto, password: hashedPassword });
  }
}
```

### ✅ Good - Controller Delegates to Service

```typescript
@Controller('users')
export class UsersController {
  constructor(private readonly userService: UserService) {}

  @Post()
  async create(
    @Body() dto: CreateUserRequestDto,
    @CurrentUser() user: JwtUserDetailsDto,
  ): Promise<UserResponseDto> {
    // ✅ YES! Only delegates to service
    return this.userService.create(dto, user.id);
  }
}
```

### Responsibilities

**Controllers should ONLY handle:**

- HTTP request/response concerns
- Parameter extraction
- Delegating to services

**Services should handle:**

- All business logic
- Data validation and transformation
- Database operations
- External API calls
- Business rules and constraints
