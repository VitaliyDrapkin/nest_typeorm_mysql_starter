---
globs: src/modules/**/services/*.ts
---

# Database Access Rules

## ⛔ DO NOT create custom repositories

**All database operations should be done directly in services via @InjectRepository.**

## Repository Injection

```typescript
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(UserEntity)
    private readonly userRepository: Repository<UserEntity>,
  ) {}
}
```

## TypeORM Methods

```typescript
// Retrieval
await this.userRepository.findOne({ where: { id } });
await this.userRepository.find({ where: filters });
await this.userRepository.findAndCount({ where: filters, skip, take });
await this.userRepository.count({ where: filters });

// Create/Update
await this.userRepository.save(entity);
await this.userRepository.save([entities]);
await this.userRepository.update({ id }, updateData);

// Delete
await this.userRepository.delete({ id });
```

## Update with Conditions

**Prefer `update()` over `createQueryBuilder()` for simple updates** - it's more readable and concise.

```typescript
import { LessThan, In } from 'typeorm';

// Simple update with multiple conditions and operators
const result = await this.gameRepository.update(
  {
    status: 'ongoing',
    updatedAt: LessThan(oneHourAgo),
  },
  { status: 'canceled' },
);
const updatedCount = result.affected || 0;

// Update with IN operator
await this.orderRepository.update(
  { status: In(['pending', 'processing']) },
  { status: 'expired' },
);
```

Use `createQueryBuilder()` only for complex scenarios (OR logic, joins, subqueries).

## Dynamic Filters

Transform DTO parameters into TypeORM operators:

```typescript
import { In, ILike, Between, LessThan, MoreThan } from 'typeorm';

private buildFilters(query: GetUsersQueryDto): Record<string, any> {
  const filters: Record<string, any> = {};

  const strategies: Record<string, ((value: any) => Record<string, any>) | null> = {
    status: (value: string[]) => ({ status: In(value) }),
    name: (value: string) => ({ name: ILike(`%${value}%`) }),
    email: (value: string) => ({ email: ILike(`%${value}%`) }),
    createdAtRange: (value: { start: Date; end: Date }) => ({
      createdAt: Between(value.start, value.end)
    }),
  };

  for (const [key, value] of Object.entries(query)) {
    if (value === undefined || value === null) continue;

    const strategy = strategies[key];
    if (strategy) {
      Object.assign(filters, strategy(value));
    }
  }

  return filters;
}

// Usage
const filters = this.buildFilters(query);
const [users, total] = await this.userRepository.findAndCount({
  where: filters,
  skip: query.skip,
  take: query.take,
});
```

## Complex Queries via QueryBuilder

```typescript
async getUsersWithStats(minOrders: number): Promise<UserEntity[]> {
  return await this.userRepository
    .createQueryBuilder('user')
    .leftJoin('user.orders', 'order')
    .select([
      'user.id',
      'user.name',
      'COUNT(order.id) as orderCount',
      'SUM(order.total) as totalSpent',
    ])
    .where('user.status = :status', { status: 'active' })
    .groupBy('user.id')
    .having('COUNT(order.id) >= :minOrders', { minOrders })
    .orderBy('totalSpent', 'DESC')
    .getRawMany();
}
```

## Summary

- ❌ DO NOT create custom repositories
- ✅ Use @InjectRepository in services
- ✅ TypeORM methods: find, findOne, save, update, delete, count
- ✅ Prefer `update()` with conditions over `createQueryBuilder()` when possible
- ✅ Use TypeORM operators (LessThan, In, IsNull, etc.) in update conditions
- ✅ buildFilters() for dynamic filters
- ✅ createQueryBuilder() only for complex queries (JOIN, GROUP BY, HAVING, OR logic)
